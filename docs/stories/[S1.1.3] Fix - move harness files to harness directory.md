WINDSURF TASK — MOVE FAST BENCH HARNESS INTO harness/ PACKAGE (SAFE REFACTOR)

CRITICAL SAFETY RULES (NON-NEGOTIABLE)
	1.	Do NOT modify any baseline files
	•	baseline/structural.py
	•	any files under baseline/
	2.	Do NOT change any detection logic
	•	No threshold changes
	•	No sequencing changes
	•	No scoring changes
	3.	This is a structural refactor only
	•	Imports, paths, and packaging
	•	Behavior must remain identical

If any algorithmic logic changes, the task has failed.

⸻

Objective

Refactor the Fast Bench orchestration code into a dedicated harness/ package, improving structure and clarity while preserving behavior.

After this task:
	•	All harness code lives under harness/
	•	The benchmark runs via python -m harness.run
	•	Output, detectors, and evaluation behavior are unchanged

⸻

Files to Move into harness/

Move the following files into a new directory named harness/:
	•	run.py
	•	detectors.py
	•	eval.py
	•	io.py
	•	config.yaml

Add:
	•	harness/__init__.py (empty)

⸻

Step 1 — Create the harness/ Package

Create directory:

harness/

Add file:

harness/__init__.py


⸻

Step 2 — Move Files

Move:

run.py        → harness/run.py
detectors.py  → harness/detectors.py
eval.py       → harness/eval.py
io.py         → harness/io.py
config.yaml   → harness/config.yaml

Do not duplicate files. Move them.

⸻

Step 3 — Fix Imports (REQUIRED)

harness/run.py

Replace dynamic io.py loading (if present)
If run.py dynamically loads io.py via importlib, remove that logic entirely.

Instead, add:

from harness import io as _io


⸻

Update imports
Change:

from detectors import DETECTORS, DetectorFn
from eval import add_forward_returns, build_comparison_table, summarize_forward_returns

To:

from harness.detectors import DETECTORS, DetectorFn
from harness.eval import add_forward_returns, build_comparison_table, summarize_forward_returns


⸻

Fix config path resolution
Replace:

cfg = _io.load_config("config.yaml")

With:

from pathlib import Path

CONFIG_PATH = Path(__file__).parent / "config.yaml"
cfg = _io.load_config(CONFIG_PATH)

This ensures correct behavior regardless of working directory.

⸻

harness/detectors.py

Ensure all imports are package-qualified.

Example:

from harness.eval import ...

Imports from baseline.* remain unchanged.

⸻

harness/eval.py and harness/io.py

If these files import each other, ensure imports are package-qualified:

from harness import io

or

from harness.io import ...

Do NOT use relative filesystem imports.

⸻

Step 4 — Verify Execution Entry Point

Ensure harness/run.py has:

if __name__ == "__main__":
    main()

The benchmark must now be runnable via:

python -m harness.run

Do not rely on direct script execution paths.

⸻

Step 5 — Sanity Checks (MANDATORY)

After refactor, perform these checks:
	1.	Run:

python -m harness.run


	2.	Confirm:
	•	Baseline sanity print still appears
	•	Output files are written exactly as before
	•	Detector-scoped filenames are preserved
	3.	Confirm:
	•	No baseline files were modified
	•	No behavior changes occurred

⸻

Forbidden Actions (Restated)

You may NOT:
	•	Modify baseline logic
	•	Rename detectors
	•	Change output formats
	•	Change evaluation math
	•	Add multiprocessing or performance changes

⸻

Acceptance Criteria

This task is complete when:
	•	harness/ contains all orchestration code
	•	All imports resolve cleanly
	•	The benchmark runs via python -m harness.run
	•	Output matches pre-refactor behavior
	•	Baseline integrity is preserved

⸻

End of Task

