Excellent — this is the right moment to lock the seam and then move to execution without ambiguity.

I’ll do this in two clean parts, exactly as you asked:
	1.	Identify what must be identified from the two baseline files (the decision artifacts, not the code itself)
	2.	Give you a Windsurf / Codex SINGLE-FILE PROMPT that implements the baseline correctly and executes inside wyckoff_fast_bench

No guessing, no refactoring, no drift.

⸻

Part 1 — What must be identified from the two files

From only these two files:
	•	kapman_v0_handwritten_structural.py
	•	structural.py

we need to identify five very specific things.
Once these are identified, everything else becomes mechanical.

⸻

1. The true algorithm entry point (most important)

We must identify the function(s) that actually kick off detection, not wrappers.

This means:
	•	A function that:
	•	accepts OHLCV (or a DataFrame / bars abstraction)
	•	initiates structural analysis
	•	eventually produces events or structural states

❌ Not:
	•	functions that just package results
	•	functions that map to enums
	•	functions that format outputs for a harness

This is the function the adapter will call.

⸻

2. The core structural detectors (algorithmic heart)

We must identify the lowest-level functions that:
	•	Compute swing highs / lows
	•	Establish support / resistance
	•	Detect breaks, tests, springs, climaxes
	•	Compute scores or confidences

These functions:
	•	may live in structural.py
	•	are usually called repeatedly
	•	should not reference any benchmark contracts

These define what you believe Wyckoff structure actually is.

⸻

3. The native event representation (pre-contract)

We must identify how events exist before the old harness touches them, e.g.:
	•	dicts
	•	tuples
	•	lightweight objects
	•	intermediate structures

Specifically:
	•	event identity
	•	event timestamp (or bar index)
	•	raw score / strength

This is what Fast Bench should adapt from, not the post-processed WyckoffSignal.

⸻

4. The old harness boundary (what to ignore)

We must explicitly mark where the old wyckoff_bench contract begins, including:
	•	EventCode
	•	WyckoffSignal
	•	ScoreName
	•	direction/role mapping
	•	evaluator logic

Everything above this boundary is not baseline logic and must not be promoted.

⸻

5. The minimal callable surface for Fast Bench

From (1)–(4), we must end up with:

“If Fast Bench wants to run the baseline on one symbol, it should call this function, pass this data, and expect this raw output.”

That sentence must be answerable without hand-waving.

Once it is, the adapter is trivial.

⸻

Part 2 — Windsurf / Codex prompt to implement the baseline

Below is the SINGLE-FILE PROMPT that:
	•	assumes you have restored the two files untouched
	•	performs the analysis above
	•	implements the baseline integration correctly
	•	executes inside wyckoff_fast_bench
	•	enforces immutability

Paste this verbatim into Windsurf.

⸻

WINDSURF TASK — IDENTIFY ALGORITHM SEAM AND IMPLEMENT BASELINE ADAPTER

CRITICAL RULE (NON-NEGOTIABLE)

You may NOT modify, refactor, or edit the following files in any way:
	•	baseline/kapman_v0_handwritten_structural.py
	•	baseline/structural.py

They are immutable research artifacts.

If any change is made to these files, the task has failed.

⸻

Objective
	1.	Identify the true algorithm seam in the handwritten baseline
	2.	Implement a Fast Bench adapter that calls the baseline correctly
	3.	Wire the baseline into Fast Bench so it can be executed symbol-by-symbol

This task must:
	•	preserve baseline behavior byte-for-byte
	•	remove dependency on the old wyckoff_bench harness
	•	make no assumptions about future sequencing or scoring tweaks

⸻

Step 1 — READ-ONLY ANALYSIS (MANDATORY)

Inspect read-only:
	•	baseline/kapman_v0_handwritten_structural.py
	•	baseline/structural.py

From these files, identify and document:
	1.	The function(s) that initiate structural detection
	2.	The core structural computation functions
	3.	The native (pre-contract) event representation
	4.	Where old harness concepts begin (EventCode, WyckoffSignal, etc.)
	5.	The minimal function that should be called by Fast Bench

Document this analysis as comments only in a new file (see Step 2).

⸻

Step 2 — Create a Pure Adapter (NEW FILE ONLY)

Create:

baseline/adapter.py

This file must:
	•	Import the baseline modules
	•	Call the identified algorithm entry point
	•	Capture native baseline outputs
	•	Translate them into a pandas DataFrame with columns:
	•	symbol
	•	date
	•	event
	•	score

All translation happens here.

Do NOT:
	•	change baseline logic
	•	inject config into baseline
	•	normalize or reinterpret scores beyond schema needs

⸻

Step 3 — Integrate Adapter into Fast Bench

In detectors.py:
	•	Import the adapter
	•	Define:

baseline_detector(df, cfg)

This function must:
	•	accept OHLCV for one symbol
	•	call the adapter
	•	return sparse events only
	•	remain stateless

No logic is allowed here beyond delegation.

⸻

Step 4 — Minimal Execution Sanity Check

In run.py:
	•	On the first symbol only:
	•	run baseline_detector
	•	print:
	•	number of events
	•	unique event names
	•	min / max event date

This confirms correct wiring.

⸻

Forbidden Actions (Restated)

You may NOT:
	•	Modify baseline source files
	•	Copy old harness files (contract.py, evaluator.py, etc.)
	•	Re-implement EventCode or WyckoffSignal in baseline
	•	Normalize scores inside baseline
	•	Add sequencing logic

⸻

Acceptance Criteria

This task is complete when:
	•	Baseline files remain unchanged
	•	Adapter calls the true algorithm seam
	•	Fast Bench can run the baseline on a symbol
	•	Output events match prior baseline behavior
	•	Full-universe execution is possible

⸻

Execution Authorization

You are authorized to:
	•	Create new adapter files
	•	Modify detectors.py, run.py, README.md
	•	Import baseline modules
	•	Translate outputs

You are not authorized to modify baseline logic.

⸻

End of Task

Proceed autonomously, respecting immutability and stopping once integration is complete.

⸻
