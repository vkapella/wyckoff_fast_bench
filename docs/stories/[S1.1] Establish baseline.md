Below is a Windsurf / Codex SINGLE-FILE PROMPT you can paste verbatim into Windsurf, scoped to your qyckoff_fast_bench repo.

This prompt is narrowly focused on incorporating your existing handwritten baseline exactly as-is, while removing hard-coding and repo-specific assumptions, and wiring it cleanly into the Fast Bench harness.

No algorithm changes.
No “simplification.”
No refactoring beyond what is strictly required for reuse.

⸻

WINDSURF TASK — INTEGRATE HANDWRITTEN WYCKOFF BASELINE INTO FAST BENCH

Objective

Integrate an existing handwritten Wyckoff structural detector into the qyckoff_fast_bench repository as the baseline detector, while:
	•	Preserving all detection logic and scoring behavior
	•	Removing hard-coded paths, globals, and repo-specific assumptions
	•	Making the detector callable symbol-by-symbol by the Fast Bench harness
	•	Avoiding any algorithmic refactor or behavioral drift

This task is adapter + de-hardcoding only, not algorithm redesign.

⸻

Baseline Source

The user will place the following files into:

wyckoff_fast_bench/baseline/
	•	kapman_v0_handwritten_structural.py
	•	structural.py
	•	(additional referenced files may be supplied if imports fail)

These files collectively define the authoritative baseline detection logic.

⸻

Non-Negotiable Constraints
	1.	Do not change detection logic
	•	No threshold changes
	•	No scoring changes
	•	No condition changes
	2.	No algorithm refactoring
	•	Only parameterization and dependency injection
	•	Only removal of hardcoded paths / globals
	3.	Fast Bench owns orchestration
	•	Baseline code must not:
	•	read files
	•	read environment variables
	•	assume working directory
	•	assume database access
	4.	Baseline code must become a pure function of OHLCV
	•	Input: pandas DataFrame (single symbol)
	•	Output: events + scores

⸻

Required Repository Layout

Ensure this structure exists:

qyckoff_fast_bench/
├── baseline/
│   ├── init.py
│   ├── kapman_v0_handwritten_structural.py
│   └── structural.py
├── detectors.py
├── run.py
├── eval.py
├── io.py
├── config.yaml
└── data/
└── ohlcv_parquet/

⸻

Step 1 — Audit and De-Hardcode Baseline Files

Inspect files under baseline/ and identify:
	•	Hard-coded paths
	•	Assumed working directories
	•	Implicit globals
	•	Hidden configuration constants

Perform only the following allowed changes:

Allowed Changes
	•	Replace hard-coded values with:
	•	function arguments
	•	keyword arguments with defaults
	•	Move configuration constants to:
	•	a single config dict
	•	Make all imports relative to baseline/
	•	Remove any I/O (file reads, prints beyond debugging)

Forbidden Changes
	•	Altering logic
	•	Altering thresholds
	•	Reordering rule evaluation
	•	Combining or splitting conditions

⸻

Step 2 — Define a Clean Baseline Entry Point

Inside baseline/, create a single canonical entry function:

Purpose:
	•	Accept OHLCV for one symbol
	•	Invoke existing logic
	•	Return a standardized event DataFrame

Requirements:
	•	Function lives in a baseline module
	•	Signature must accept:
	•	pandas DataFrame
	•	optional config dict
	•	Must NOT assume symbol universe context

Conceptual interface (do not invent new logic):
	•	Input: df (one symbol, full history)
	•	Output columns:
	•	symbol
	•	date
	•	event
	•	score

This function becomes the only surface Fast Bench touches.

⸻

Step 3 — Adapt Baseline into detectors.py

In detectors.py:
	1.	Import the baseline entry function
	2.	Wrap it in a baseline_detector(df, cfg) adapter that:
	•	passes through config
	•	normalizes column names if required
	•	filters to a minimal event set initially (e.g., SPRING, BC)

Do NOT:
	•	Add new logic
	•	Add sequencing
	•	Normalize scores yet

This is a shim only.

⸻

Step 4 — Ensure Symbol-by-Symbol Compatibility

The baseline detector must:
	•	Operate on a single symbol’s OHLCV
	•	Be stateless between calls
	•	Produce deterministic output

If baseline code currently assumes multi-symbol context, refactor only the data access pattern — not the logic.

⸻

Step 5 — Validate Integration

Add a minimal validation in run.py:
	•	Load one symbol from Parquet
	•	Run baseline_detector
	•	Print:
	•	number of events
	•	unique event types
	•	date range

This confirms correct wiring before full-universe runs.

⸻

Step 6 — Document the Contract

Update README.md to include:
	•	Statement that:
	•	baseline detector is handwritten and authoritative
	•	Fast Bench does not reinterpret logic
	•	Instructions on:
	•	how to update baseline files safely
	•	what kinds of changes require re-benchmarking

⸻

Acceptance Criteria

This task is complete when:
	•	baseline/ code runs without hard-coded paths
	•	baseline_detector() produces identical events to prior usage
	•	Fast Bench can call the baseline on any symbol independently
	•	No detection logic was modified
	•	No database, filesystem, or environment dependencies remain

⸻

Execution Authorization

You are authorized to:
	•	Modify files under baseline/
	•	Create adapters in detectors.py
	•	Make minimal structural changes required for reuse
	•	Request additional baseline files if imports fail

If additional files are referenced but missing, stop and report exactly which imports are required.

Do not guess.

⸻

End of Task

Proceed autonomously until the baseline detector is cleanly integrated and callable by Fast Bench.

⸻
